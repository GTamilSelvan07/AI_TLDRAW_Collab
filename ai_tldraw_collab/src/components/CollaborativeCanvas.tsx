// src/components/CollaborativeCanvas.tsx
import { useCallback, useEffect, useMemo, useRef } from 'react';
import {
  Tldraw,
  TLComponents,
  track,
  useEditor,
  Editor,
  createShapeId,
} from 'tldraw';
import { useSyncDemo } from '@tldraw/sync';
import 'tldraw/tldraw.css';

// Custom collaborator cursor component
const CustomCollaboratorCursor = track(({ collaborator }) => {
  // Safety check for malformed data
  if (!collaborator || !collaborator.point || typeof collaborator.point !== 'object') {
    return null;
  }
  
  const color = collaborator.color || '#2B44FF';
  
  return (
    <div
      style={{
        position: 'absolute',
        top: collaborator.point.y,
        left: collaborator.point.x,
        transform: 'translate(-50%, -50%)',
        pointerEvents: 'none',
        zIndex: 999,
      }}
    >
      {/* Cursor pointer */}
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
        <path 
          d="M5.5 2L19 15.5L12 17L7 22L5.5 2Z" 
          fill={color} 
          stroke="white" 
          strokeWidth="1.5"
        />
      </svg>
      
      {/* User label */}
      <div
        style={{
          position: 'absolute',
          top: 24,
          left: 0,
          backgroundColor: color,
          color: 'white',
          padding: '3px 8px',
          borderRadius: '4px',
          fontSize: '12px',
          fontWeight: 'bold',
          whiteSpace: 'nowrap',
          boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
        }}
      >
        {collaborator.name || 'User'}
      </div>
    </div>
  );
});

// Collaborator info panel component
const CollaborationInfoPanel = track(() => {
  const editor = useEditor();
  
  try {
    // This can throw if editor isn't ready yet
    const collaborators = editor.getCollaborators();
    
    if (!collaborators || collaborators.length === 0) return null;
    
    return (
      <div className="collaboration-info-panel">
        <div className="collaborators-list">
          <div className="panel-title">Collaborators ({collaborators.length})</div>
          {collaborators.map((collaborator) => (
            <div 
              key={collaborator.userId} 
              className="collaborator-item"
              style={{ borderLeft: `3px solid ${collaborator.color || '#1E88E5'}` }}
            >
              <div className="collaborator-name">{collaborator.userName || 'User'}</div>
            </div>
          ))}
        </div>
      </div>
    );
  } catch (error) {
    console.error("Error rendering collaboration panel:", error);
    return null;
  }
});

interface CollaborativeCanvasProps {
  isSidePanelOpen: boolean;
  aiData?: any[]; // Shapes generated by the AI
}

export const CollaborativeCanvas = ({ 
  isSidePanelOpen,
  aiData
}: CollaborativeCanvasProps) => {
  const editorRef = useRef<Editor | null>(null);
  
  // Generate a unique room ID
  const roomId = useMemo(() => 'tldraw-collab-room', []);
  
  // Generate a unique user ID and random name
  const userId = useMemo(() => `user-${Math.random().toString(36).substring(2, 9)}`, []);
  const userName = useMemo(() => `User ${userId.slice(-4)}`, [userId]);
  
  // Custom user color
  const userColor = useMemo(() => {
    const colors = [
      '#2B44FF', '#0FA5E9', '#00D084', '#F7A5E6', 
      '#FF5733', '#E91E63', '#7C3AED', '#F59E0B'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }, []);
  
  // Set up collaboration with useSyncDemo
  const store = useSyncDemo({
    roomId,
    userInfo: {
      id: userId,
      name: userName,
      color: userColor,
    },
  });
  
  // Handle editor mount
  const handleMount = useCallback((editor: Editor) => {
    editorRef.current = editor;
    console.log('Editor mounted with room ID:', roomId);
    console.log(`You are connected as: ${userName} (${userId})`);
  }, [roomId, userId, userName]);
  
  // Custom components
  const components = useMemo<TLComponents>(() => ({
    CollaboratorCursor: CustomCollaboratorCursor,
    InFrontOfTheCanvas: CollaborationInfoPanel,
  }), []);
  
  // Apply AI-generated shapes when they arrive
  useEffect(() => {
    if (!aiData || aiData.length === 0 || !editorRef.current) return;
    
    const editor = editorRef.current;
    
    try {
      // Start a batch update
      editor.batch(() => {
        // Create shapes based on AI data
        const shapesToCreate = aiData.map(shape => {
          // Create a unique ID for this shape
          const id = createShapeId();
          
          // The base shape structure
          const baseShape = {
            id,
            type: shape.type || 'geo',
            x: shape.x || 100,
            y: shape.y || 100,
          };
          
          // Different shape types need different prop structures
          if (shape.type === 'text') {
            // For text shapes we need to use w and h but no text property
            return {
              ...baseShape,
              props: {
                w: shape.props?.w || 200,
                h: shape.props?.h || 100,
                color: shape.props?.color || 'black',
                size: shape.props?.size || 'm',
                font: shape.props?.font || 'draw',
                align: shape.props?.align || 'middle',
                verticalAlign: shape.props?.verticalAlign || 'middle',
                growY: shape.props?.growY || 0,
                text: '', // Initialize with empty string
              }
            };
          } else if (shape.type === 'geo') {
            // For geo shapes with labels
            return {
              ...baseShape,
              props: {
                w: shape.props?.w || 100,
                h: shape.props?.h || 100,
                geo: shape.props?.geo || 'rectangle',
                color: shape.props?.color || 'blue',
                fill: shape.props?.fill || 'none',
                dash: shape.props?.dash || 'draw',
                size: shape.props?.size || 'm',
                labelColor: shape.props?.labelColor || 'black',
                text: shape.props?.text || '',  // This is valid for geo shapes
              }
            };
          } else {
            // Default for other shapes
            return {
              ...baseShape,
              props: shape.props || {
                w: 100,
                h: 100,
                color: 'blue',
              }
            };
          }
        });
        
        // Create all shapes at once
        editor.createShapes(shapesToCreate);
        
        // After creating shapes, set text for text shapes separately
        // This avoids the validation error
        shapesToCreate.forEach(shape => {
          if (shape.type === 'text' && shape.props) {
            const textContent = shape.props.text || 'AI Generated';
            // Using updateShapes to set text for text shapes
            editor.updateShapes([
              {
                id: shape.id,
                type: 'text',
                props: {
                  text: textContent
                }
              }
            ]);
          }
        });
        
        // Zoom to fit all shapes
        setTimeout(() => editor.zoomToFit(), 100);
      });
    } catch (error) {
      console.error("Error creating AI shapes:", error);
      console.log(error);
    }
  }, [aiData]);
  
  return (
    <div className={`canvas-container ${isSidePanelOpen ? 'with-panel' : ''}`}>
      <Tldraw
        store={store}
        components={components}
        onMount={handleMount}
      />
    </div>
  );
};